diff --git a/es/enum-collection.js b/es/enum-collection.js
index a3f2754ba7faa1d9e58130f4fc5faab1057c523b..eb024e86e64062cb90ab3e228dfe5501a3abebaf 100644
--- a/es/enum-collection.js
+++ b/es/enum-collection.js
@@ -51,7 +51,7 @@ export class EnumCollectionClass extends EnumExtensionClass {
     // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken
     this[Object.keys(init).some(k => k === 'items') ? ITEMS : 'items'] = items;
     // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken
-    this[Object.keys(init).some(k => k === 'values') ? VALUES : 'values'] = items;
+    // this[Object.keys(init).some(k => k === 'values') ? VALUES : 'values'] = items;
 
     // Override the `instanceof` operator rule
     // @ts-expect-error: because override the instanceof operator
@@ -103,6 +103,18 @@ export class EnumCollectionClass extends EnumExtensionClass {
   valuesEnum() {
     return this.items.valuesEnum();
   }
+  get values() {
+    return this.items.map(({ value }) => value);
+  }
+  get labels() {
+    return this.items.map(({ label }) => label);
+  }
+  pluck(field) {
+    return this.items.map(item => {
+      if (field in item.raw) return item.raw[field];
+      else if (Object.keys(item).includes(field)) return item[field];
+    });
+  }
 
   // eslint-disable-next-line @typescript-eslint/ban-types
 
diff --git a/es/enum.d.ts b/es/enum.d.ts
index 6e50ce26edf47fa75bc44fe4adbd35b08bbd3b5d..96b2dde7fb8166acc93f265757e646b4e140bc5b 100644
--- a/es/enum.d.ts
+++ b/es/enum.d.ts
@@ -1,4 +1,4 @@
-import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnumInit, ValueTypeFromSingleInit } from './types';
+import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnumInit, ValueTypeFromSingleInit, IEnumItems } from './types';
 /**
  * **EN:** Generate an enum collection, the enum value supports `number` and `string` types, and the
  * enum name supports localization solutions
@@ -15,7 +15,7 @@ import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnum
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
+export declare function _Enum<const T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
 /**
  * **EN:** Generate an enum based on an object array
  *
@@ -32,9 +32,14 @@ export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = En
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
-export declare namespace Enum {
-    export var localize: (content: "enum-plus.options.all" | (string & {}) | undefined) => any;
-    var _a: (obj: Record<string, unknown> | undefined) => void;
-    export { _a as extends };
+export declare function _Enum<const T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
+/**
+ * @example
+ *   const Week = Enum(['Sun', 'Mon']);
+ */
+export declare function _Enum<const K extends string, V extends EnumValue = ValueTypeFromSingleInit<number, K>>(init: K[], options?: EnumInitOptions<Record<K, number>, K, V>): IEnum<Record<K, number>, K, V> & EnumExtension<Record<K, number>, K, V>;
+export const Enum: typeof _Enum & {
+    localize: (content: "enum-plus.options.all" | (string & {}) | undefined) => any;
+    extends: (obj: Record<string, unknown> | undefined) => void;
+    [Symbol.hasInstance]: (value: unknown) => value is IEnumItems<any, any, any>;
 }
\ No newline at end of file
diff --git a/es/enum.js b/es/enum.js
index 7cf8088f99300ff73efb4f2b69dc0c6f98369cdf..dd5a05adaa9acbfcec5071f6bfd911bb2333d3f5 100644
--- a/es/enum.js
+++ b/es/enum.js
@@ -38,6 +38,8 @@ let enumExtensions;
 
 export function Enum(init, options) {
   if (Array.isArray(init)) {
+    if (["string", "number", "bigint"].includes(typeof init[0]))
+      init = init.map((key, value) => ({ key, value }));
     const initMap = getInitMapFromArray(init, options);
     // @ts-expect-error: because of typing extend in tests
     return new EnumCollectionClass(initMap, options);
@@ -47,6 +49,9 @@ export function Enum(init, options) {
   }
 }
 
+Object.defineProperty(Enum, Symbol.hasInstance, {
+  value: value => value instanceof EnumCollectionClass,
+});
 /**
  * **EN:** Global localization function, used to convert enum item text to localized text. Only need
  * to be set once, effective globally. This method need to be set at the project entry, before
diff --git a/es/types.d.ts b/es/types.d.ts
index c4bed727fe756a62826c72c8dd9fe809329cce3e..2f7c81075bcd02d7ead714c88511837c3b1e2098 100644
--- a/es/types.d.ts
+++ b/es/types.d.ts
@@ -1,5 +1,5 @@
 import type { EnumItemClass } from './enum-item';
-import type { ITEMS, KEYS, VALUES } from './utils';
+import type { ITEMS, KEYS, VALUES, ENUM_COLLECTION } from './utils';
 /**
  * **EN:** Enum initialization options
  *
@@ -73,10 +73,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
 }) & (T extends {
     values: any;
 } ? {
-    [VALUES]: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    [VALUES]: V[];
 } : {
-    /** @deprecated Use `items` instead */
-    values: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    values: V[];
 }) & (T extends {
     keys: any;
 } ? {
@@ -93,7 +92,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
      * 常在typescript作为类型声明使用，例如： `type Props = { week: typeof Week['keys'] }`
      */
     keys: K[];
-});
+}) & {
+    labels: (T[keyof T] extends object & { label: any; } ? T[keyof T]["label"][] : never[]);
+};
 /**
  * **EN:** Enum item collection interface, excluding members inherited from the array
  *
@@ -104,6 +105,8 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
  * @interface IEnumItems
  */
 export interface IEnumItems<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>> {
+    readonly [ENUM_COLLECTION]: true;
+    pluck<F extends (T[keyof T] extends object ? keyof T[keyof T] : never)>(field: F): (F extends keyof T[keyof T] ? T[keyof T][F][] : never[]);
     /**
      * **EN:** Get the enumeration item by key or value
      *
diff --git a/lib/enum-collection.js b/lib/enum-collection.js
index 7f2616801710825b4926513a58f3f15499ec84a6..cc730a5ca4333ff95ce983e3459c1b75d9c9d034 100644
--- a/lib/enum-collection.js
+++ b/lib/enum-collection.js
@@ -48,7 +48,7 @@ class EnumCollectionClass extends EnumExtensionClass {
         // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken
         this[Object.keys(init).some((k) => k === 'items') ? utils_1.ITEMS : 'items'] = items;
         // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken
-        this[Object.keys(init).some((k) => k === 'values') ? utils_1.VALUES : 'values'] = items;
+        // this[Object.keys(init).some((k) => k === 'values') ? utils_1.VALUES : 'values'] = items;
         // Override the `instanceof` operator rule
         // @ts-expect-error: because override the instanceof operator
         this[Symbol.hasInstance] = (instance) => {
@@ -114,6 +114,18 @@ class EnumCollectionClass extends EnumExtensionClass {
     get rawType() {
         return this.items.rawType;
     }
+    get values() {
+        return this.items.map(({ value }) => value);
+    }
+    get labels() {
+        return this.items.map(({ label }) => label);
+    }
+    pluck(field) {
+        return this.items.map(item => {
+            if (field in item.raw) return item.raw[field];
+            else if (Object.keys(item).includes(field)) return item[field];
+        });
+    }
 }
 exports.EnumCollectionClass = EnumCollectionClass;
 _a = utils_1.ENUM_COLLECTION;
diff --git a/lib/enum.d.ts b/lib/enum.d.ts
index 97f687f27238afc8383d73b8e3c64fd015792f18..e4e51ce842efcc720acff7f0c987c5f21ea5e173 100644
--- a/lib/enum.d.ts
+++ b/lib/enum.d.ts
@@ -1,4 +1,4 @@
-import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnumInit, ValueTypeFromSingleInit } from './types';
+import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnumInit, ValueTypeFromSingleInit, IEnumItems } from './types';
 /**
  * **EN:** Generate an enum collection, the enum value supports `number` and `string` types, and the
  * enum name supports localization solutions
@@ -15,7 +15,7 @@ import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnum
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
+declare function _Enum<const T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
 /**
  * **EN:** Generate an enum based on an object array
  *
@@ -32,9 +32,14 @@ export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = En
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
-export declare namespace Enum {
-    export var localize: (content: EnumLocaleExtends["LocaleKeys"] | (string & {}) | undefined) => any;
-    var _a: (obj: Record<string, unknown> | undefined) => void;
-    export { _a as extends };
+declare function _Enum<const T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
+/**
+ * @example
+ *   const Week = Enum(['Sun', 'Mon']);
+ */
+declare function _Enum<const K extends string, V extends EnumValue = ValueTypeFromSingleInit<number, K>>(init: K[], options?: EnumInitOptions<Record<K, number>, K, V>): IEnum<Record<K, number>, K, V> & EnumExtension<Record<K, number>, K, V>;
+export const Enum: typeof _Enum & {
+    localize: (content: EnumLocaleExtends["LocaleKeys"] | (string & {}) | undefined) => any;
+    extends: (obj: Record<string, unknown> | undefined) => void;
+	[Symbol.hasInstance]: (value: unknown) => value is IEnumItems<any, any, any>;
 }
diff --git a/lib/enum.js b/lib/enum.js
index 73d051266d566536819476bca02eefd46b95b4ba..63528c9477d69ca4044421590c5b815bfc5a759a 100644
--- a/lib/enum.js
+++ b/lib/enum.js
@@ -6,6 +6,8 @@ const utils_1 = require("./utils");
 let enumExtensions;
 function Enum(init, options) {
     if (Array.isArray(init)) {
+        if (["string", "number", "bigint"].includes(typeof init[0]))
+            init = init.map((key, value) => ({ key, value }));
         const initMap = getInitMapFromArray(init, options);
         // @ts-expect-error: because of typing extend in tests
         return new enum_collection_1.EnumCollectionClass(initMap, options);
@@ -15,6 +17,9 @@ function Enum(init, options) {
         return new enum_collection_1.EnumCollectionClass(init, options);
     }
 }
+Object.defineProperty(Enum, Symbol.hasInstance, {
+    value: value => value instanceof EnumCollectionClass,
+});
 /**
  * **EN:** Global localization function, used to convert enum item text to localized text. Only need
  * to be set once, effective globally. This method need to be set at the project entry, before
diff --git a/lib/types.d.ts b/lib/types.d.ts
index c4bed727fe756a62826c72c8dd9fe809329cce3e..2f7c81075bcd02d7ead714c88511837c3b1e2098 100644
--- a/lib/types.d.ts
+++ b/lib/types.d.ts
@@ -1,5 +1,5 @@
 import type { EnumItemClass } from './enum-item';
-import type { ITEMS, KEYS, VALUES } from './utils';
+import type { ITEMS, KEYS, VALUES, ENUM_COLLECTION } from './utils';
 /**
  * **EN:** Enum initialization options
  *
@@ -73,10 +73,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
 }) & (T extends {
     values: any;
 } ? {
-    [VALUES]: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    [VALUES]: V[];
 } : {
-    /** @deprecated Use `items` instead */
-    values: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    values: V[];
 }) & (T extends {
     keys: any;
 } ? {
@@ -93,7 +92,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
      * 常在typescript作为类型声明使用，例如： `type Props = { week: typeof Week['keys'] }`
      */
     keys: K[];
-});
+}) & {
+    labels: (T[keyof T] extends object & { label: any; } ? T[keyof T]["label"][] : never[]);
+};
 /**
  * **EN:** Enum item collection interface, excluding members inherited from the array
  *
@@ -104,6 +105,8 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
  * @interface IEnumItems
  */
 export interface IEnumItems<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>> {
+    readonly [ENUM_COLLECTION]: true;
+    pluck<F extends (T[keyof T] extends object ? keyof T[keyof T] : never)>(field: F): (F extends keyof T[keyof T] ? T[keyof T][F][] : never[]);
     /**
      * **EN:** Get the enumeration item by key or value
      *
diff --git a/package.json b/package.json
index ccdeca5e35165b1df27807a21e5d9b04686ae0c8..a706ed638f87b27a80a50b3730efb450e44ce0f5 100644
--- a/package.json
+++ b/package.json
@@ -66,6 +66,7 @@
       "default": "./es-legacy/index.js"
     },
     "./types": "./lib/types.d.ts",
+    "./utils": "./lib/utils.d.ts",
     "./package.json": "./package.json"
   },
   "main": "lib/index.js",
