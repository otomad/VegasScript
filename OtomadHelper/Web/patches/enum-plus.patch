diff --git a/es/enum-collection.js b/es/enum-collection.js
index a3f2754ba7faa1d9e58130f4fc5faab1057c523b..eb024e86e64062cb90ab3e228dfe5501a3abebaf 100644
--- a/es/enum-collection.js
+++ b/es/enum-collection.js
@@ -51,7 +51,7 @@ export class EnumCollectionClass extends EnumExtensionClass {
     // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken
     this[Object.keys(init).some(k => k === 'items') ? ITEMS : 'items'] = items;
     // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken
-    this[Object.keys(init).some(k => k === 'values') ? VALUES : 'values'] = items;
+    // this[Object.keys(init).some(k => k === 'values') ? VALUES : 'values'] = items;
 
     // Override the `instanceof` operator rule
     // @ts-expect-error: because override the instanceof operator
@@ -103,6 +103,18 @@ export class EnumCollectionClass extends EnumExtensionClass {
   valuesEnum() {
     return this.items.valuesEnum();
   }
+  get values() {
+    return this.items.map(({ value }) => value);
+  }
+  get labels() {
+    return this.items.map(({ label }) => label);
+  }
+  pluck(field) {
+    return this.items.map(item => {
+      if (field in item.raw) return item.raw[field];
+      else if (Object.keys(item).includes(field)) return item[field];
+    });
+  }
 
   // eslint-disable-next-line @typescript-eslint/ban-types
 
diff --git a/es/enum.d.ts b/es/enum.d.ts
index 6e50ce26edf47fa75bc44fe4adbd35b08bbd3b5d..4d73f1b798ac30054d75e1c39e30aeb0891718d2 100644
--- a/es/enum.d.ts
+++ b/es/enum.d.ts
@@ -15,7 +15,7 @@ import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnum
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
+export declare function Enum<const T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
 /**
  * **EN:** Generate an enum based on an object array
  *
@@ -32,7 +32,7 @@ export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = En
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
+export declare function Enum<const T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
 export declare namespace Enum {
     export var localize: (content: "enum-plus.options.all" | (string & {}) | undefined) => any;
     var _a: (obj: Record<string, unknown> | undefined) => void;
diff --git a/es/types.d.ts b/es/types.d.ts
index c4bed727fe756a62826c72c8dd9fe809329cce3e..a2e6cfedffdcfb842805e5b06b522353f72a3e0f 100644
--- a/es/types.d.ts
+++ b/es/types.d.ts
@@ -73,10 +73,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
 }) & (T extends {
     values: any;
 } ? {
-    [VALUES]: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    [VALUES]: V[];
 } : {
-    /** @deprecated Use `items` instead */
-    values: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    values: V[];
 }) & (T extends {
     keys: any;
 } ? {
@@ -93,7 +92,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
      * 常在typescript作为类型声明使用，例如： `type Props = { week: typeof Week['keys'] }`
      */
     keys: K[];
-});
+}) & {
+    labels: (T[keyof T] extends object & { label: any; } ? T[keyof T]["label"][] : never[]);
+};
 /**
  * **EN:** Enum item collection interface, excluding members inherited from the array
  *
@@ -104,6 +105,7 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
  * @interface IEnumItems
  */
 export interface IEnumItems<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>> {
+    pluck<F extends (T[keyof T] extends object ? keyof T[keyof T] : never)>(field: F): (F extends keyof T[keyof T] ? T[keyof T][F][] : never[]);
     /**
      * **EN:** Get the enumeration item by key or value
      *
diff --git a/lib/enum-collection.js b/lib/enum-collection.js
index 7f2616801710825b4926513a58f3f15499ec84a6..cc730a5ca4333ff95ce983e3459c1b75d9c9d034 100644
--- a/lib/enum-collection.js
+++ b/lib/enum-collection.js
@@ -48,7 +48,7 @@ class EnumCollectionClass extends EnumExtensionClass {
         // @ts-expect-error: because use ITEMS to avoid naming conflicts in case of 'items' field name is taken
         this[Object.keys(init).some((k) => k === 'items') ? utils_1.ITEMS : 'items'] = items;
         // @ts-expect-error: because use VALUES to avoid naming conflicts in case of 'values' field name is taken
-        this[Object.keys(init).some((k) => k === 'values') ? utils_1.VALUES : 'values'] = items;
+        // this[Object.keys(init).some((k) => k === 'values') ? utils_1.VALUES : 'values'] = items;
         // Override the `instanceof` operator rule
         // @ts-expect-error: because override the instanceof operator
         this[Symbol.hasInstance] = (instance) => {
@@ -114,6 +114,18 @@ class EnumCollectionClass extends EnumExtensionClass {
     get rawType() {
         return this.items.rawType;
     }
+    get values() {
+        return this.items.map(({ value }) => value);
+    }
+    get labels() {
+        return this.items.map(({ label }) => label);
+    }
+    pluck(field) {
+        return this.items.map(item => {
+            if (field in item.raw) return item.raw[field];
+            else if (Object.keys(item).includes(field)) return item[field];
+        });
+    }
 }
 exports.EnumCollectionClass = EnumCollectionClass;
 _a = utils_1.ENUM_COLLECTION;
diff --git a/lib/enum.d.ts b/lib/enum.d.ts
index 97f687f27238afc8383d73b8e3c64fd015792f18..86fc484a969d1d49daac3ec790eb6213d33612ce 100644
--- a/lib/enum.d.ts
+++ b/lib/enum.d.ts
@@ -15,7 +15,7 @@ import type { EnumInit, EnumInitOptions, EnumKey, EnumValue, IEnum, StandardEnum
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
+export declare function Enum<const T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T, options?: EnumInitOptions<T, K, V>): IEnum<T, K, V> & EnumExtension<T, K, V>;
 /**
  * **EN:** Generate an enum based on an object array
  *
@@ -32,7 +32,7 @@ export declare function Enum<T extends EnumInit<K, V>, K extends EnumKey<T> = En
  *
  * @returns Enum collection | 枚举集合
  */
-export declare function Enum<T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
+export declare function Enum<const T extends Record<string, any>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>>(init: T[], options?: EnumInitOptions<T, K, V>): IEnum<StandardEnumInit<string, V>, string, V> & EnumExtension<T, K, V>;
 export declare namespace Enum {
     export var localize: (content: EnumLocaleExtends["LocaleKeys"] | (string & {}) | undefined) => any;
     var _a: (obj: Record<string, unknown> | undefined) => void;
diff --git a/lib/types.d.ts b/lib/types.d.ts
index c4bed727fe756a62826c72c8dd9fe809329cce3e..a2e6cfedffdcfb842805e5b06b522353f72a3e0f 100644
--- a/lib/types.d.ts
+++ b/lib/types.d.ts
@@ -73,10 +73,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
 }) & (T extends {
     values: any;
 } ? {
-    [VALUES]: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    [VALUES]: V[];
 } : {
-    /** @deprecated Use `items` instead */
-    values: EnumItemClass<T[K], K, V>[] & IEnumItems<T, K, V>;
+    values: V[];
 }) & (T extends {
     keys: any;
 } ? {
@@ -93,7 +92,9 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
      * 常在typescript作为类型声明使用，例如： `type Props = { week: typeof Week['keys'] }`
      */
     keys: K[];
-});
+}) & {
+    labels: (T[keyof T] extends object & { label: any; } ? T[keyof T]["label"][] : never[]);
+};
 /**
  * **EN:** Enum item collection interface, excluding members inherited from the array
  *
@@ -104,6 +105,7 @@ export type IEnum<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V
  * @interface IEnumItems
  */
 export interface IEnumItems<T extends EnumInit<K, V>, K extends EnumKey<T> = EnumKey<T>, V extends EnumValue = ValueTypeFromSingleInit<T[K], K>> {
+    pluck<F extends (T[keyof T] extends object ? keyof T[keyof T] : never)>(field: F): (F extends keyof T[keyof T] ? T[keyof T][F][] : never[]);
     /**
      * **EN:** Get the enumeration item by key or value
      *
